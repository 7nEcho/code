# PiteAgents 项目基础说明

## 统一分页配置与使用指南

### 📋 概述

本项目使用 **MyBatis-Plus 分页插件**实现统一的分页功能，通过 YAML 配置和工具类提供优雅、安全、可配置的分页管理方案。

---

## 一、后端分页实现

### 1.1 技术栈

- **分页框架**: MyBatis-Plus Pagination Plugin
- **配置管理**: Spring Boot Configuration Properties
- **工具类**: 统一分页工具类 `PaginationUtils`

### 1.2 YAML 配置

在 `application.yml` 中配置全局分页参数：

```yaml
pite-agents:
  pagination:
    # 默认页面大小（当前端未传入 size 参数时使用）
    default-page-size: 20
    
    # 最大页面大小（防止恶意查询，超过此值将被限制）
    max-page-size: 1000
    
    # 默认排序字段（驼峰命名，会自动转换为下划线）
    default-sort-field: "createdAt"
    
    # 默认排序方向 (ASC/DESC)
    default-sort-direction: "DESC"
```

**配置说明**：
- `default-page-size`: 未指定页面大小时的默认值
- `max-page-size`: 系统允许的最大页面大小，超过此值会被强制限制
- `default-sort-field`: 默认排序字段，使用 Java 驼峰命名（如 `createdAt`）
- `default-sort-direction`: 默认排序方向，可选值为 `ASC`（升序）或 `DESC`（降序）

### 1.3 核心组件

#### 1.3.1 配置类 - `PaginationProperties`

位置：`back/piteAgents/src/main/java/pox/com/piteagents/config/PaginationProperties.java`

```java
@Component
@ConfigurationProperties(prefix = "pite-agents.pagination")
public class PaginationProperties {
    private int defaultPageSize = 20;
    private int maxPageSize = 1000;
    private String defaultSortField = "createdAt";
    private String defaultSortDirection = "DESC";
    
    // 提供安全的参数获取方法
    public int getSafePageSize(Integer pageSize) { ... }
    public long getSafePageNum(Integer pageNum) { ... }
    public String getSafeSortField(String sortField) { ... }
    public String getSafeSortDirection(String sortDirection) { ... }
}
```

**职责**：
- 读取并管理 YAML 配置
- 提供参数安全校验方法
- 确保分页参数在合理范围内

#### 1.3.2 工具类 - `PaginationUtils`

位置：`back/piteAgents/src/main/java/pox/com/piteagents/common/utils/PaginationUtils.java`

```java
@Component
public class PaginationUtils {
    
    // 创建基础分页对象
    public <T> IPage<T> createPage(Integer pageNum, Integer pageSize);
    
    // 创建带排序的分页对象
    public <T> IPage<T> createPage(Integer pageNum, Integer pageSize, 
                                   String sortField, String sortDirection);
    
    // 记录分页信息（用于日志）
    public void logPaginationInfo(IPage<?> page, String action);
}
```

**核心功能**：
1. **参数校验**：验证并规范化分页参数
2. **安全检查**：排序字段白名单验证，防止 SQL 注入
3. **字段转换**：自动将驼峰命名转换为数据库下划线命名
4. **默认值处理**：使用配置文件中的默认值填充缺失参数

**排序字段白名单**：
```java
private static final Set<String> ALLOWED_SORT_FIELDS = new HashSet<>(Arrays.asList(
    "id", "createdAt", "updatedAt", "name", "title", "status", 
    "sortOrder", "priority", "messageCount", "totalTokens"
));
```

### 1.4 Controller 层使用示例

#### 示例：AgentController

```java
@RestController
@RequestMapping("/api/agents")
@RequiredArgsConstructor
public class AgentController {
    
    private final IAgentService agentService;
    private final PaginationUtils paginationUtils;
    
    @GetMapping
    public ApiResponse<IPage<AgentDTO>> listAgents(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) Integer page,      // 页码（可选，默认1）
            @RequestParam(required = false) Integer size,      // 页面大小（可选，使用配置的默认值）
            @RequestParam(required = false) String sortField,  // 排序字段（可选）
            @RequestParam(required = false) String sortDirection) { // 排序方向（可选）
        
        // 使用工具类创建分页对象
        IPage<AgentDTO> pageParam = paginationUtils.createPage(page, size, sortField, sortDirection);
        
        // 调用 Service 层执行分页查询
        IPage<AgentDTO> agents = agentService.listAgents(category, status, keyword, pageParam);
        
        // 记录分页信息（可选）
        paginationUtils.logPaginationInfo(agents, "查询Agent列表");
        
        return ApiResponse.success(agents);
    }
}
```

**参数说明**：
- `page`: 页码，**从 1 开始**，可选（默认使用配置的第一页）
- `size`: 每页大小，可选（默认使用 `default-page-size` 配置）
- `sortField`: 排序字段，可选（默认使用 `default-sort-field` 配置）
- `sortDirection`: 排序方向，可选值 `ASC`/`DESC`（默认使用 `default-sort-direction` 配置）

### 1.5 Service 层使用示例

#### 接口定义

```java
public interface IAgentService {
    IPage<AgentDTO> listAgents(String category, String status, 
                               String keyword, IPage<AgentDTO> page);
}
```

#### 实现示例

```java
@Override
@Transactional(readOnly = true)
public IPage<AgentDTO> listAgents(String category, String status, 
                                  String keyword, IPage<AgentDTO> page) {
    // 构建查询条件
    LambdaQueryWrapper<AgentPO> queryWrapper = Wrappers.lambdaQuery();
    
    if (keyword != null && !keyword.trim().isEmpty()) {
        queryWrapper.and(wrapper -> wrapper
                .like(AgentPO::getName, keyword)
                .or()
                .like(AgentPO::getDescription, keyword)
        );
    }
    
    if (category != null && !category.trim().isEmpty()) {
        queryWrapper.eq(AgentPO::getCategory, category);
    }
    
    if (status != null && !status.trim().isEmpty()) {
        queryWrapper.eq(AgentPO::getStatus, status);
    }

    // 创建 MyBatis-Plus 分页对象
    Page<AgentPO> mpPage = new Page<>(page.getCurrent(), page.getSize());
    
    // 复制排序信息
    if (page.orders() != null && !page.orders().isEmpty()) {
        mpPage.addOrder(page.orders());
    }
    
    // 执行分页查询
    IPage<AgentPO> agentPage = agentMapper.selectPage(mpPage, queryWrapper);

    // 转换为 DTO 并返回
    Page<AgentDTO> resultPage = new Page<>(agentPage.getCurrent(), 
                                           agentPage.getSize(), 
                                           agentPage.getTotal());
    resultPage.setRecords(agentPage.getRecords().stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList()));
    
    // 复制排序信息到结果
    if (agentPage.orders() != null && !agentPage.orders().isEmpty()) {
        resultPage.addOrder(agentPage.orders());
    }
    
    return resultPage;
}
```

### 1.6 API 请求示例

#### 基础分页查询
```http
GET /api/agents?page=1&size=20
```

#### 带搜索条件的分页查询
```http
GET /api/agents?category=编程&status=ACTIVE&keyword=助手&page=2&size=10
```

#### 带排序的分页查询
```http
GET /api/agents?page=1&size=20&sortField=updatedAt&sortDirection=DESC
```

#### 完整参数示例
```http
GET /api/agents?category=编程&status=ACTIVE&page=1&size=15&sortField=name&sortDirection=ASC
```

### 1.7 响应格式

MyBatis-Plus 分页响应结构：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "records": [
      {
        "id": 1,
        "name": "通用助手",
        "description": "一个通用的 AI 助手",
        "category": "通用",
        "status": "ACTIVE",
        "createdAt": "2025-10-24T03:29:42",
        "updatedAt": "2025-10-24T03:29:42",
        "config": {
          "model": "glm-4.6",
          "temperature": 0.7,
          "maxTokens": 2000,
          "topP": 0.95
        }
      }
    ],
    "total": 100,        // 总记录数
    "size": 20,          // 每页大小
    "current": 1,        // 当前页码（从1开始）
    "pages": 5,          // 总页数
    "orders": [          // 排序信息
      {
        "column": "created_at",
        "asc": false
      }
    ]
  }
}
```

**字段说明**：
- `records`: 当前页的数据列表
- `total`: 总记录数
- `size`: 每页显示的记录数
- `current`: 当前页码（**从 1 开始**）
- `pages`: 总页数
- `orders`: 排序信息数组

---

## 二、前端分页实现

### 2.1 Agent 列表页面

位置：`front/piteAgents-admin/src/views/agent/List.vue`

#### 状态管理

```javascript
const currentPage = ref(1)  // 当前页码，从1开始
const totalPages = ref(0)   // 总页数
const totalElements = ref(0) // 总记录数

const searchParams = reactive({
  keyword: '',
  category: '',
  status: '',
  page: 1,                  // 请求页码，从1开始
  size: 12,                 // 每页大小
  sortField: '',            // 排序字段（可选）
  sortDirection: '',        // 排序方向（可选）
})
```

#### 数据加载

```javascript
const loadAgents = async () => {
  try {
    loading.value = true
    const response = await getAgentList(searchParams)

    // 处理 MyBatis-Plus 分页响应
    const pageData = response.data
    agents.value = pageData.records || []      // 数据列表
    totalPages.value = pageData.pages || 0     // 总页数
    totalElements.value = pageData.total || 0  // 总记录数
    currentPage.value = pageData.current || 1  // 当前页码
  } catch (error) {
    console.error('加载 Agent 列表失败:', error)
  } finally {
    loading.value = false
  }
}
```

#### 分页操作

```javascript
// 翻页处理
const handlePageChange = (page) => {
  searchParams.page = page
  loadAgents()
}

// 搜索处理（重置到第一页）
const handleSearch = () => {
  searchParams.page = 1  // 重置到第一页
  loadAgents()
}
```

#### 模板示例

```vue
<div v-if="totalPages > 1" class="pagination">
  <button
    @click="handlePageChange(currentPage - 1)"
    :disabled="currentPage <= 1"
    class="pagination-button"
  >
    <ChevronLeftIcon class="icon-sm" />
  </button>
  <span class="pagination-info">
    第 {{ currentPage }} / {{ totalPages }} 页，共 {{ totalElements }} 条
  </span>
  <button
    @click="handlePageChange(currentPage + 1)"
    :disabled="currentPage >= totalPages"
    class="pagination-button"
  >
    <ChevronRightIcon class="icon-sm" />
  </button>
</div>
```

### 2.2 工具列表页面

位置：`front/piteAgents-admin/src/views/tool/List.vue`

实现方式与 Agent 列表相同，参考上述代码结构。

### 2.3 API 调用示例

#### API 请求参数

```javascript
// 基础分页
getAgentList({ page: 1, size: 20 })

// 带筛选条件
getAgentList({ 
  category: '编程', 
  status: 'ACTIVE',
  page: 2, 
  size: 15 
})

// 带排序
getAgentList({ 
  page: 1, 
  size: 20,
  sortField: 'updatedAt',
  sortDirection: 'DESC'
})
```

#### 响应数据处理

```javascript
const response = await getAgentList(params)
const pageData = response.data

// 提取分页数据
const records = pageData.records      // 数据列表
const total = pageData.total          // 总记录数
const currentPage = pageData.current  // 当前页码（从1开始）
const totalPages = pageData.pages     // 总页数
const pageSize = pageData.size        // 每页大小
```

---

## 三、分页使用规范

### 3.1 页码规范

⚠️ **重要提醒**：

- **后端（MyBatis-Plus）**: 页码从 **1** 开始
- **前端**: 页码也从 **1** 开始
- 与之前的 Spring Data 分页（从 0 开始）不同

### 3.2 参数传递规范

#### Controller 层

```java
// ✅ 正确：所有参数都设置为可选
@GetMapping
public ApiResponse<IPage<AgentDTO>> listAgents(
        @RequestParam(required = false) String keyword,
        @RequestParam(required = false) Integer page,
        @RequestParam(required = false) Integer size,
        @RequestParam(required = false) String sortField,
        @RequestParam(required = false) String sortDirection) {
    // ...
}

// ❌ 错误：使用默认值会导致前端无法省略参数
@GetMapping
public ApiResponse<IPage<AgentDTO>> listAgents(
        @RequestParam(defaultValue = "1") int page,  // 不推荐
        @RequestParam(defaultValue = "20") int size) { // 不推荐
    // ...
}
```

#### Service 层

```java
// 接口定义
IPage<AgentDTO> listAgents(String category, String status, 
                           String keyword, IPage<AgentDTO> page);

// 实现要点
public IPage<AgentDTO> listAgents(..., IPage<AgentDTO> page) {
    // 1. 创建 MyBatis-Plus 分页对象
    Page<AgentPO> mpPage = new Page<>(page.getCurrent(), page.getSize());
    
    // 2. 复制排序信息
    if (page.orders() != null && !page.orders().isEmpty()) {
        mpPage.addOrder(page.orders());
    }
    
    // 3. 执行查询
    IPage<AgentPO> result = mapper.selectPage(mpPage, queryWrapper);
    
    // 4. 转换为 DTO 并返回
    Page<AgentDTO> resultPage = new Page<>(result.getCurrent(), 
                                           result.getSize(), 
                                           result.getTotal());
    resultPage.setRecords(result.getRecords().stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList()));
    
    return resultPage;
}
```

### 3.3 安全规范

#### 排序字段安全

只允许使用白名单中的字段进行排序：

```java
// ✅ 安全的排序字段
sortField=createdAt
sortField=updatedAt
sortField=name
sortField=status

// ❌ 不安全的排序字段（会抛出异常）
sortField=password
sortField=secretKey
sortField=drop table users
```

#### 页面大小限制

```java
// ✅ 合理的页面大小
size=10
size=20
size=100

// ⚠️ 超过最大值会被限制
size=10000  // 会被限制为 max-page-size (1000)

// ✅ 未传入时使用默认值
// 缺省 size 参数 → 使用 default-page-size (20)
```

---

## 四、最佳实践

### 4.1 Controller 开发规范

1. **注入分页工具类**：
   ```java
   private final PaginationUtils paginationUtils;
   ```

2. **使用工具类创建分页对象**：
   ```java
   IPage<DTO> pageParam = paginationUtils.createPage(page, size, sortField, sortDirection);
   ```

3. **调用 Service 层方法**：
   ```java
   IPage<DTO> result = service.listItems(filters, pageParam);
   ```

4. **记录分页日志（可选）**：
   ```java
   paginationUtils.logPaginationInfo(result, "操作描述");
   ```

5. **返回统一响应**：
   ```java
   return ApiResponse.success(result);
   ```

### 4.2 Service 开发规范

1. **接口方法签名**：
   ```java
   IPage<DTO> listItems(FilterParams..., IPage<DTO> page);
   ```

2. **创建 MyBatis-Plus 分页对象**：
   ```java
   Page<PO> mpPage = new Page<>(page.getCurrent(), page.getSize());
   ```

3. **复制排序信息**：
   ```java
   if (page.orders() != null && !page.orders().isEmpty()) {
       mpPage.addOrder(page.orders());
   }
   ```

4. **执行查询**：
   ```java
   IPage<PO> result = mapper.selectPage(mpPage, queryWrapper);
   ```

5. **转换为 DTO**：
   ```java
   Page<DTO> resultPage = new Page<>(result.getCurrent(), result.getSize(), result.getTotal());
   resultPage.setRecords(result.getRecords().stream()
           .map(this::convertToDTO)
           .collect(Collectors.toList()));
   return resultPage;
   ```

### 4.3 前端开发规范

1. **状态初始化**：
   ```javascript
   const currentPage = ref(1)  // 从1开始
   const searchParams = reactive({
     page: 1,     // 从1开始
     size: 20,
     sortField: '',
     sortDirection: ''
   })
   ```

2. **响应数据处理**：
   ```javascript
   const pageData = response.data
   items.value = pageData.records || []
   totalPages.value = pageData.pages || 0
   totalElements.value = pageData.total || 0
   currentPage.value = pageData.current || 1
   ```

3. **翻页逻辑**：
   ```javascript
   const handlePageChange = (page) => {
     searchParams.page = page
     loadData()
   }
   ```

4. **搜索重置**：
   ```javascript
   const handleSearch = () => {
     searchParams.page = 1  // 搜索时重置到第一页
     loadData()
   }
   ```

5. **分页器模板**：
   ```vue
   <button :disabled="currentPage <= 1" @click="handlePageChange(currentPage - 1)">
     上一页
   </button>
   <span>第 {{ currentPage }} / {{ totalPages }} 页，共 {{ totalElements }} 条</span>
   <button :disabled="currentPage >= totalPages" @click="handlePageChange(currentPage + 1)">
     下一页
   </button>
   ```

---

## 五、常见问题

### Q1: 为什么页码从 1 开始？

**A**: MyBatis-Plus 的分页插件设计为从 1 开始，这也符合用户的直觉认知。之前使用 Spring Data 分页时从 0 开始。

### Q2: 如何修改默认分页大小？

**A**: 在 `application.yml` 中修改 `pite-agents.pagination.default-page-size` 配置即可，无需修改代码。

### Q3: 如何添加新的排序字段？

**A**: 在 `PaginationUtils` 的 `ALLOWED_SORT_FIELDS` 白名单中添加新字段：

```java
private static final Set<String> ALLOWED_SORT_FIELDS = new HashSet<>(Arrays.asList(
    "id", "createdAt", "updatedAt", "name", "title", "status",
    "yourNewField"  // 添加新字段
));
```

### Q4: 为什么需要排序字段白名单？

**A**: 防止 SQL 注入攻击。如果直接将用户输入的排序字段拼接到 SQL 中，攻击者可能通过构造特殊字符串执行恶意 SQL。

### Q5: 前端如何处理 Spring Data 到 MyBatis-Plus 的迁移？

**A**: 主要修改响应数据的字段映射：

| Spring Data | MyBatis-Plus | 说明 |
|------------|--------------|------|
| `content` | `records` | 数据列表 |
| `totalElements` | `total` | 总记录数 |
| `totalPages` | `pages` | 总页数 |
| `number` | `current` | 当前页码 |
| 从 0 开始 | 从 1 开始 | 页码起始值 |

### Q6: 如何处理大数据量分页？

**A**: 
1. 配置合理的 `max-page-size` 限制（默认 1000）
2. 前端避免一次性加载所有数据
3. 使用索引优化的排序字段（如 `createdAt`、`id`）
4. 考虑使用游标分页或流式查询（如果需要）

### Q7: 分页查询性能优化建议？

**A**:
1. **添加数据库索引**：为常用的排序字段添加索引
   ```sql
   CREATE INDEX idx_created_at ON agent(created_at);
   CREATE INDEX idx_updated_at ON agent(updated_at);
   ```

2. **避免深度分页**：页码越大，查询越慢，建议：
   - 限制最大页码（如 100 页）
   - 使用游标分页代替 offset 分页

3. **合理设置页面大小**：
   - 列表页：10-20 条
   - 下拉选择：50-100 条
   - 避免超过 1000 条

---

## 六、代码清单

### 6.1 后端核心文件

| 文件路径 | 作用 |
|---------|------|
| `config/PaginationProperties.java` | 分页配置属性类 |
| `common/utils/PaginationUtils.java` | 分页工具类 |
| `config/MyBatisPlusConfig.java` | MyBatis-Plus 配置（包含分页插件） |
| `controller/AgentController.java` | Agent 控制器示例 |
| `service/IAgentService.java` | Agent 服务接口 |
| `service/impl/AgentServiceImpl.java` | Agent 服务实现 |

### 6.2 前端核心文件

| 文件路径 | 作用 |
|---------|------|
| `views/agent/List.vue` | Agent 列表页（分页示例） |
| `views/tool/List.vue` | 工具列表页（分页示例） |
| `api/agent.js` | Agent API 封装 |
| `api/tool.js` | 工具 API 封装 |

### 6.3 配置文件

| 文件路径 | 作用 |
|---------|------|
| `resources/application.yml` | 全局配置（包含分页配置） |

---

## 七、快速开始

### 7.1 添加新的分页查询接口

#### 步骤 1: Controller 层

```java
@GetMapping
public ApiResponse<IPage<YourDTO>> listItems(
        @RequestParam(required = false) Integer page,
        @RequestParam(required = false) Integer size,
        @RequestParam(required = false) String sortField,
        @RequestParam(required = false) String sortDirection) {
    
    IPage<YourDTO> pageParam = paginationUtils.createPage(page, size, sortField, sortDirection);
    IPage<YourDTO> result = yourService.listItems(pageParam);
    paginationUtils.logPaginationInfo(result, "查询XXX列表");
    return ApiResponse.success(result);
}
```

#### 步骤 2: Service 接口

```java
IPage<YourDTO> listItems(IPage<YourDTO> page);
```

#### 步骤 3: Service 实现

```java
@Override
public IPage<YourDTO> listItems(IPage<YourDTO> page) {
    // 创建分页对象
    Page<YourPO> mpPage = new Page<>(page.getCurrent(), page.getSize());
    
    // 复制排序
    if (page.orders() != null && !page.orders().isEmpty()) {
        mpPage.addOrder(page.orders());
    }
    
    // 执行查询
    IPage<YourPO> result = yourMapper.selectPage(mpPage, queryWrapper);
    
    // 转换为 DTO
    Page<YourDTO> resultPage = new Page<>(result.getCurrent(), result.getSize(), result.getTotal());
    resultPage.setRecords(result.getRecords().stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList()));
    
    return resultPage;
}
```

#### 步骤 4: 前端页面

```javascript
// 状态
const page = ref(1)
const size = ref(20)
const items = ref([])
const totalPages = ref(0)

// 加载数据
const loadItems = async () => {
  const response = await getItemList({ page: page.value, size: size.value })
  const pageData = response.data
  items.value = pageData.records
  totalPages.value = pageData.pages
  page.value = pageData.current
}

// 翻页
const changePage = (newPage) => {
  page.value = newPage
  loadItems()
}
```

### 7.2 如果需要自定义排序

#### 后端

在 Controller 层传入特定的排序字段：

```java
// 为特定查询指定默认排序
String defaultSortField = sortField != null ? sortField : "updatedAt";
IPage<DTO> pageParam = paginationUtils.createPage(page, size, defaultSortField, sortDirection);
```

#### 前端

传入排序参数：

```javascript
await getItemList({ 
  page: 1, 
  size: 20,
  sortField: 'name',      // 按名称排序
  sortDirection: 'ASC'    // 升序
})
```

---

## 八、迁移指南

### 8.1 从 Spring Data 分页迁移到 MyBatis-Plus 分页

#### 后端迁移检查清单

- [ ] 移除 `org.springframework.data.domain.Page` 导入
- [ ] 添加 `com.baomidou.mybatisplus.core.metadata.IPage` 导入
- [ ] 修改方法签名使用 `IPage<T>` 代替 `Page<T>`
- [ ] 使用 `page.getCurrent()` 代替 `pageable.getPageNumber() + 1`
- [ ] 使用 `page.getSize()` 代替 `pageable.getPageSize()`
- [ ] 响应字段从 `content` 改为 `records`
- [ ] 移除 `PageImpl` 的使用

#### 前端迁移检查清单

- [ ] 页码初始值从 `0` 改为 `1`
- [ ] 响应字段 `content` 改为 `records`
- [ ] 响应字段 `totalElements` 改为 `total`
- [ ] 响应字段 `totalPages` 改为 `pages`
- [ ] 响应字段 `number` 改为 `current`
- [ ] 分页器判断从 `currentPage === 0` 改为 `currentPage <= 1`
- [ ] 分页器判断从 `currentPage >= totalPages - 1` 改为 `currentPage >= totalPages`
- [ ] 页码显示从 `currentPage + 1` 改为 `currentPage`

---

## 九、测试建议

### 9.1 后端测试

```java
// 测试默认分页
GET /api/agents
// 预期：返回第1页，每页20条（使用配置的默认值）

// 测试指定分页
GET /api/agents?page=2&size=10
// 预期：返回第2页，每页10条

// 测试排序
GET /api/agents?sortField=name&sortDirection=ASC
// 预期：按名称升序排列

// 测试安全限制
GET /api/agents?size=10000
// 预期：页面大小被限制为1000（max-page-size）

// 测试非法排序字段
GET /api/agents?sortField=invalidField
// 预期：返回400错误，提示不支持的排序字段
```

### 9.2 前端测试

1. **测试翻页功能**：
   - 点击"上一页"/"下一页"按钮
   - 验证页码正确递增/递减
   - 验证第一页时"上一页"按钮禁用
   - 验证最后一页时"下一页"按钮禁用

2. **测试搜索功能**：
   - 输入搜索关键词
   - 验证页码重置为 1
   - 验证搜索结果正确显示

3. **测试筛选功能**：
   - 切换筛选条件
   - 验证页码重置为 1
   - 验证筛选结果正确

4. **测试分页信息显示**：
   - 验证 "第 X / Y 页，共 Z 条" 显示正确
   - 验证总记录数准确

---

## 十、总结

本项目的统一分页方案具有以下特点：

### ✅ 优势

1. **统一性**: 所有分页查询使用相同的工具类和配置
2. **可配置**: 通过 YAML 配置分页参数，无需修改代码
3. **安全性**: 排序字段白名单、页面大小限制、SQL 注入防护
4. **易维护**: 集中管理分页逻辑，减少重复代码
5. **规范性**: 统一的参数命名和返回格式
6. **灵活性**: 支持动态排序字段和方向

### 🎯 使用要点

1. 页码从 **1** 开始（MyBatis-Plus 规范）
2. 所有分页参数都是**可选**的，未传入时使用配置的默认值
3. 排序字段必须在**白名单**中，否则会抛出异常
4. 页面大小会被限制在 `max-page-size` 以内
5. 前端响应数据使用 `records`、`total`、`current`、`pages` 字段

### 📝 维护建议

1. 添加新的排序字段时，记得更新白名单
2. 根据业务需求调整 YAML 配置的默认值
3. 定期检查分页查询的性能，必要时添加数据库索引
4. 保持前后端分页逻辑的一致性

---

**最后更新时间**: 2025-10-25  
**文档版本**: v1.0  
**维护人员**: piteAgents Team

